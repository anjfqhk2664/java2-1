# 이상현 202130421

## 4월 19일 강의

추상 메소드
    abstract로 선언된 메소드, 메소드의 코드는 없고 원형만 선언

추상 클래스
    추상 메소드를 가지며, abstract로 선언된 클래스
    추상 메소드 없이, avstract로 선언한 클래스

추상 클래스 상속
    추상 클래스를 상속받으면 추상 클래스가 됨
    서브 클래스도 abstract로 선언해야 함

추상 클래스 구현
    서브 클래스에서 슈퍼 클래스의 추상 메소드 구현(오버라이딩)
    추상 클래스를 구현한 서브 클래스는 추상 클래스 아님

추상 클래스의 목적
    상속을 위한 슈퍼 클래스로 활용하는 것
    서브 클래스에서 추상 메소드 구현
    다형성 실현

자바의 인터페이스
    클래스가 구현해야 할 메소드들이 선언되는 추상형
    인터페이스 선언
        interface 키워드로 선언
        Ex) public interface SeriaDiver(...)

자바 인터페이스에 대한 변화
    Java 7까지
        상수와 추상메소드 포함
        default 메소드 포함(Java 8)
        private 메소드 포함(Java 9)
        static 메소드 포함(Java 9)

인터페이스의 구성 요소들
    상수
    추상메소드
    default 메소드
    private 메소드
    static 메소드

여전히 인터페이스에는 필드(멤버 변수) 선언 불가

인터페이스 간에 상속 가능
    인터페이스를 상속하여 확장된 인터페이스 작성 가능
        extends 키워드로 상속 선언

인터페이스 다중 상속 허용

인터페이스의 추상 메소드를 모두 구현한 클래스 작성
    implements 키워드 사용
    여러 개의 인터페이스 동시 구현 가능

인터페이스 구현 사례
    PhoneInterface 인터페이스를 구현한 SamsungPhone 클래스
    SamsungPhone 클래스는 PhoneInterface의 default 메소드 상속

패키지
    서로 관련된 클래스와 인터페이스를 컴파일한 클래스 파일들을 묶어 놓은 디렉터리
    하나의 응용프로그램은 한 개 이상의 패키지로 작성
    패키지는 jar 파일로 압축할 수 있음

모듈
    여러 패키지와 이미지 등의 자원을 모아 놓은 컨테이너
    하나의 모듈을 하나의 .jmod 파일에 저장

Java 9부터 모듈화 도입
    플랫폼의 모듈화
        Java 9부터 자바 API의 모든 클래스들(자바 실행 환경)을 패키지 기반에서 모듈들로 완전히 재구성
    응용프로그램의 모듈화
        클래스들은 패키지로 만들고, 다시 패키지

모듈화의 목적
    Java 9부터 자바 API를 여러 모둘(99개)로 분할
        Java 8까지는 rt.jar의 한 파일에 모든 API 저장
    응용프로그램이 실행할 때 꼭 필요한 모듈들로만 실행 환경 구축
        메모리 자원이 열악한 작은 소형 기기에 꼭 필요한 모듈로 구성된 작은 크기의 실행 이미지를 만들기 위함
    
모듈의 현실
    Java 9부터 전면적으로 도입
    복잡한 개념
    큰 자바 응용프로그램에는 개발, 유지보수 등에 적함
    현실적으로 모듈로 나누어 자바 프로그램을 작성할 필요 없음

자바 JDK에 제공되는 모둘 파일들
    자바가 설치된 jmods 디렉터리에 모듈 파일 존재
        .imod 확장자를 가진 파일
        모듈은 수십개
        모듈 파일은 ZIP 포맷으로 압축된 파일
    모듈 파일에는 자바 API의 패키지와 클래스들이 들어 있음
    jomd 명령을 이용하여 모듈 파일에 들어 있는 패키지를 풀어 낼 수 있음

패키지 사용하기, import문
다른 패키지에 작성된 클래스 사용
    import를 이용하지 않는 경우
        소스에 클래스 이름이 완전 경로명 사용

필요한 클래스만 import
    소스 시각 부분에 클래스의 경로명 import
    import 패키지, 클래스
    소스에는 클래스 명만 명시하면 됨

패키지 전체를 import
    소스 시각 부분에 패키지의 경로명 import
    import 패키지.*
    import.java.util.*

가장 큰 목적
    자바 컴포넌트들을 필요에 따라 조립하여 사용하기 위함
    컴퓨터 시스템의 불필요한 부담 감소
        세밀한 모듈화를 통해 필요 없는 모듈이 로드되지 않게 함
        소형 IoT장치에도 자바 응용프로그램이 실행되고 성능을 유지하게함

Object 클래스
    특징
        모든 자바 클래스는 반드시 Object를 상속받도록 자동 컴파일
            모든 클래스의 수퍼 클래스
            모든 클래스가 상속받는 공통 메소드 포함

wrapper 클래스
자바의 기본타입을 클래스화한 8개 클래스를 통칭

용도
    객체만 사용할 수 있는 켈렉션 등에 기본 타입의 값을 사용하기 위해 wrapper 객체로 만들어서 사용

주요 메소드
가장 많이 사용하는 integer 클래스의 주요 메소드
    다른 wrapper 클래스와 메소ㅓ드는 이와 유사

2. 메소드 종류/설명
    toString(): 객체를 문자열로 반환합니다.
    hashCode(): 객체의 해시 코드를 반환합니다.
    equals(Object obj): 다른 객체와 동등한지 여부를 판단합니다.
    getClass(): 객체의 클래스 정보를 반환합니다.
    notify(): 대기 중인 하나의 스레드를 깨웁니다.
    notifyAll(): 대기 중인 모든 스레드를 깨웁니다.
    wait(): 스레드를 일시 정지시킵니다.

박싱과 언박싱
    박싱
        기본 타입의 값을 wrapper 객체로 변환하는 것

언박싱
    Wrapper 클래스의 객체에서 기본 타입의 값을 추출하는 것
    Wrapper 클래스는 기본 데이터 타입을 감싸는 클래스로, 예를 들어 Integer, Double, Boolean 등
    언박싱은 Wrapper 클래스의 객체에서 intValue(), doubleValue(), booleanValue() 등의 메소드를 사용하여 해당 기본 타입의 값을 추출

String 활용
String의 생성:
    문자열을 생성하고 문자열 리터럴을 저장하는 객체
    쌍따옴표(" ")로 감싸진 문자열 리터럴을 사용하여 String 객체를 생성가능
    문자열 연결 (Concatenation): '+' 연산자를 사용하여 문자열을 연결가능
    문자열 리터럴과 변수, 또는 문자열 변수와 문자열 변수를 연결가능

문자열의 길이 확인:
    length() 메소드를 사용하여 문자열의 길이를 확인
    공백을 포함하여 문자열의 전체 길이를 반환

문자열 비교:
    equals() 메소드를 사용하여 두 문자열이 동일한지 비교
    equalsIgnoreCase() 메소드는 대소문자를 무시하고 비교

부분 문자열 추출:
    substring() 메소드를 사용하여 문자열의 일부분을 추출
    시작 인덱스와 종료 인덱스를 지정하여 추출

문자열 검색:
    indexOf() 메소드를 사용하여 특정 문자 또는 문자열이 처음으로 등장하는 위치확인 가능
    lastIndexOf() 메소드는 문자열의 끝에서부터 검색을 수행

문자열 분할:
    split() 메소드를 사용하여 문자열을 특정 구분자를 기준으로 분할
    분할된 부분은 문자열 배열로 반환

문자열 치환:
    replace() 메소드를 사용하여 문자열 내의 특정 문자 또는 문자열을 다른 문자열로 대체
    대체될 문자열이 없으면 원래 문자열을 그대로 반환

## 4월 12일 강의

Static 맴버와 non-Static 맴버 특성 정리

Static 맴버의 생성
1. static맴버는 클래스당 하나만 생성
2. 객체들에 의해 공유됨

[ 5주차 강의 내용 참고 ]-----------------------------------------
static 맴버
1. static맴버 선언
2. 객체 생성과 non-static 맴버의 생성
    --> non-static 맴버는 객체가 생설될 때, 객체마다 생긴다

static 맴버 사용
1. 클래스 이름으로 접근이 가능
2. 객체의 맴버로 접근이 가느
3. non-static 맴버는 클래스 이름으로 접근 안됨
----------------------------------------------------------------

static 메소드의 제약 조건 1
1. tatic 메소드는 오직 static 맴버만 접근 가능
    <1>객체가 생성되지 않은 상황에서도 static메소드는 실행될 수 있기 때문에 non-static 멤버 활용불가
    <2>non-static 메소드는 static맴버 사용 가능

static 메소드의 제약 조건 2
1. static 메소드는 this 사용불가
    <1>static 메소드는 객체 없이도 사용 가능하므로, this 레퍼런스 사용할 수 없음

final 클래스와 메소드
1. final 클래스 -> 더 이상 클래스 상속 불가능
2. final 메소드 -> 더 이상 오버라이딩 불가능

final 필드
1. final필드, 상수 선언
    <1>상수를 선언할 때 사용
    <2>상수 필드는 선선 시에 초기 값을 지정하여아 한다
    <3>상수 필드는 생성중에 필드 값을 초기화 할 수 없다

상속 ( Inheritance )
1. 상속의 선언
    <1>extends 키워드로 선언
        --> 부모 클래스를 물려받아 확장한다는 의미
    <2>부모 클래스 --> 슈퍼 클래스 ( super class )
    <3>자식 클래스 --> 서브 클래스 ( sub class )

서브 클래스 객체의 모양
1. 슈퍼 클래스는 객체와 서브 클래스의 객체는 별개
2. 서브 클래스 객체는 슈퍼 클래스 맴버 포함

자바 상속의 특징
1. 클래스 다중 상속 불허
    <1> c++는 다중상속 클래스가 가능

슈퍼 클래스의 맴버에 대한 서브 클래스의 접근
1. 슈퍼 클래스의 private 맴버
    <1>서브 클래스에서 접근할 수 없음

2. 슈퍼 클래스의 디폴트 맴버
    <1>서브 클래스가 동일한 패키지에 있을 때, 접근 가능

3. 슈퍼 클래스의 public맴버
    <1>서브 클래스는 항상 접근 가능

4. 슈퍼 클래스의 protected 상속

protected 맴버
1. protected 맴버에 대한 접근 
    <1>같은 패키지의 모든 클래스에 접근 허용
    <2>상속되는 서브 클래스에게 허용

서브 클래스와 슈퍼 클래스의 생성자 선택 
1. 슈퍼 클래스와 서브클래스
    <1>각각 여러개의 생성자 작성가능

서브 클래스의 객체가 생성될 때
1. 슈퍼 클래스 생성자 1개와 서브 클래스 생성자 1개가 실행

서브 클래스의 생성자와 슈퍼 클래스의 생성자가 결정된는 방식
1. 개발자의 명시적 선택

[ 업캐스팅과 다운캐스팅 설명?? ]

업캐스팅의 개념
1. 업캐스팅은 하위 클래스를 상위 클래스 타입으로 변환하는 것. 상속 계층 구조에서 자주 사용되며, 다형성을 활용하여 다양한 객체를 동일한 인터페이스로 다룰 수 있게 컴파일 타임 다형성을 제공하여 유연하고 확장 가능한 코드를 작성하는 데 도움이 됨

업캐스팅
1. 서브 클래스의 레퍼런스를 슈퍼 클래스 레퍼런스에 대입
2. 슈퍼 클래스 레퍼런스로 서브 클래스 객체를 가르키게 되는 현상

다운캐스팅의 개념
1. 다운캐스팅은 상위 클래스 타입을 하위 클래스 타입으로 변환하는 것. 업캐스팅과 반대되며 명시적인 형 변환을 필요로, 주로 상위 클래스로 선언된 객체를 실제로는 하위 클래스로 사용해야 할 때 사용되며 타입 안전성을 보장하기 위해 주의해서 사용해야 함

다운캐스팅
1. 슈퍼 클래스 레퍼런스를 서브 클래스 레퍼런스에 대입
2. 업캐스팅된 것을 다시 월래대로 되돌리는 것
3. 반드시 명시적 타입 변환 지정

[ 업캐스팅 레퍼런스로 객체 구별?? ]
업캐스팅된 레퍼런스로는 객체의 실제 타입을 구분하기 어려움
    --> 슈퍼 클래스에서 여러 서브 클래스에 상속되기 때문.


Instanceof 연산자 사용
1. 레퍼런스가 가르키는 객체의 타입 식별

instanceof 연산자의 활용예제 ( by.코드 )
[ ex.code ]-----------------------------------------------------
class Animal {}
class Dog extends Animal {}
class Cat extends Animal {}

public class Main {
    public static void main(String[] args) {
        Animal myDog = new Dog();
        Animal myCat = new Cat();

        System.out.println(myDog instanceof Animal); // true
        System.out.println(myDog instanceof Dog);    // true
        System.out.println(myDog instanceof Cat);    // false

        System.out.println(myCat instanceof Animal); // true
        System.out.println(myCat instanceof Dog);    // false
        System.out.println(myCat instanceof Cat);    // true
    }
}

설명: 이 예제는 instanceof 연산자를 사용하여 각 객체가 Animal 클래스, Dog 클래스 또는 Cat 클래스의 인스턴스인지를 확인한다.
[ ex.code ]------------------------------------------------------

메소드 오버라이딩의 개념
1. 메소드 오버라이딩은 상위 클래스의 메소드를 하위 클래스에서 덮어쓰는 것, 이를 통해 하위 클래스는 상위 클래스의 동작을 재정의할 수 있다. 이 개념은 다형성을 지원하며, 런타임 시에 객체의 실제 타입에 따라 적절한 메소드가 호출이 됨

오버라이딩의 목적, 다향성 실현
1. 오버라이딩 + 다향성
    <1>하나의 인터페이스에 서로 다른 구현
    <2>슈퍼 클래스의 메소드를 서브 클래세어서 각각 목적에 맞게 다르게 구현
    <3>사례

## 4월 5일 강의
자바의 예외 클래스
1. 배열의 범위를 벗어나 원소를 접근하는 예외 처리
<1> 자바에서 배열의 범위를 벗어나 원소를 접근하려고 할 때 발생하는 예외는 ArrayIndexOutOfBoundsException이고, 
이 예외는 배열의 유효하지 않은 인덱스에 접근하려고 할 때 발생 배열의 유효한 인덱스 범위는 0부터 배열의 길이 - 1까지이며, 이 범위를 벗어나는 인덱스에 접근하면 이 예외가 발생

캡슐화 : 객체를 캡슐로 싸서 내부를 볼 수 없게 하는 것
    객체의 가장 본질적인 특징
        외부의 접근으로부터 객체 보호

자바의 캡슐화
    클래스 : 객체 모양을 선언한 틀(캡슐화하는 틀)
    객체 : 생성된 실체
        클래스 내에 메소드와 필드 구현
상속
    상위 개체의 속성이 하위 개체에 물려짐
    하위 개체가 상위 개체의 속성을 모두 가지는 관계

자바 상속
    상위 클래스의 멤버를 하위 클래스가 물려받음
        상위 클래스 : 수퍼 클래스
        하위 클래스 : 서브 클래스, 수퍼 클래스 코드의 재사용, 새로운 특성 추가 가능

다형성
    같은 이름의 메소드가 클래스 혹은 객체에 따라 다르게 구현되는 것
    다형성 사례
        메소드 오버로딩 : 한 클래스 내에서 같은 이름이지만 다르게 작동하는 여러 메소드
        메소드 오버라이딩: 슈퍼 클래스의 메소드를 동일한 이름으로 서브 클래스마다 다르게 구현
소프트웨어의 생산성 향상
    컴퓨터 산업 발전에 따라 소프트웨어의 주기 단축
        소프트웨어를 빠른 속도로 생산할 필요성 증대
    객체 지향언어
        상속, 다형성, 객체, 캡슐화 등 소프트웨어 재사용을 위한 여러 장치 내장
        소프트웨어 재사용과 부분 수정 빠름
        소프트웨어를 다시 만다는 부담 대폭 줄임
        소프트웨어 생산성 향상

실세계의 대한 쉬운 모델링
    초기 프로그래밍
        수학 계산/동계 처리를 하는 등 처리 과정, 계산 절차 중요
    현대 프로그래밍
        컴퓨터가 산업 전반에 활용
        실세계에서 발생하는 일을 프로그래밍

    절차 지향 프로그래밍
        작업 순서를 표현하는 컴퓨터 명령 집함
        함수들의 집합으로 프로그램 작성
    객체 지향 프로그래밍 
        컴퓨터가 수행하는 작업을 객체들간의 상호 작용으로 표현
        클래스 혹은 객체들의 집합으로 프로그램 작성

클래스
    객체의 속성과 행위 선언
    객체의 설계도 혹은 틀

객체
    클래스의 틀로 찍어낸 실체
        프로그램 실행 중에 생성되는 실체
        메모리 공간을 갖는 구체적인 실체
        인스턴스라고도 부름

사례
    클래스: 소나타 자동차    객체: 출고된 실제 소나타 100대
    클래스: 벽시계           객체: 우리집 벽에 걸린 벽시계들
    클래스: 책상             객체: 우리가 사용중인 실제 책상들   

this
    객체 자신에 대한 레퍼런스
         컴파일러에 의해 자동관리, 개발자는 사용하기만 하면 됨
         this.멤버 형태로 멤버를 접근할 때 사용

자바의 객체 배열
    객체에 대한 레퍼런스 배열임
자바의 객체 배열 만들기 3단계
    1. 배열 레퍼런스 변수 선언
    2. 레퍼런스 배열 생성
    3. 배열의 각 원소 객체 생성

메소드
    메소드는 C/C++ 의 함수와 동일
    자바의모든 메소드는 반드시 클래스 안에 있어야함(캡슐화의 원칙)

객체 소멸
    new에 의해 할당 받은 객체와 배열 메모리를 자바 가상 기계로 되돌려 주는 행위
    소멸된 객체 공간은 가용 메모리에 포함
자바에서 사용자 임의로 객체 소멸 안 됨
    자바는 객체 소멸 연산자 없음
        객체 생성 연산자 : new
    객체 소멸은 자바 가상 기계의 고유한 역할
    자바 개발자에게는 매우 다행스러운 기능
        C/C++ 에서는 할당 받은 객체를 개발자가 프로그램 내에서 삭제해야 함
        C/C++ 의 프로그램 작성을 어렵게 만드는 요인
        자바에서는 사용하지 않는 객체나 배열을 돌려주는 코딩 책임으로부터 개발자 해방

가비지
    가리키는 레퍼런스가 하나도 없는 객체
        더 이상 접근할 수 없어 사용할 수 없게 된 메모리
가비지 컬렉션
    자바 가상 기계의 가비지 컬렉터가 자동으로 가비지 수집, 반환
    자바  가상 기계가 가비지 자동 회수
        가용 메모리 공간이 일정 이하로 부족해질 때
        가비지를 수거하여 가용 메모리 공간으로 확보
    가비지 컬렉터에 의해 자동수행

강제 가비지 컬렉션 강제수행
    System 또는 Runtime 객체의 gc() 메소드 호출
        이 코드는 자바 가상 기계에 강력한 가비지 컬렉션 요청
        그러나 자바 가상 기계가 가비지 컬렉션 시점을 전적으로 판단

패키지
    상호 관련 있는 클래스 파일(컴파일된.class)을 저장하여 관리하는 디렉터리
    자바 응용프로그램은 하나 이상의 패키지로 구성

자바의 접근 지정자
    4가지
        private, protected, public, 디폴트(접근지정자)
    접근 지정자의 목적
        클래스나 일부 멤버를 공개하여 다른 클래스에서 접근하도록 허용
        객체 지향 언어의 캡슐화 정책은 멤버를 보호하는 것
            접근 지정은 캡슐화에 묶인 보호를 일부 해체할 목적
        접근 지정자에 따른 클래스나 멤버의 공개 범위

클래스 접근지정
    다른 클래스에서 사용하도록 허용할 지 지정
    public 클래스
        다른 모든 클래스에게 접근 허용

디폴트 클래스(접근지정자 생략)
    package-private라고도 함
    같은 패키지의 클래스에만 접근 허용


## 3월 29일 강의
조건문
    Ex num1=100, num2=50;
       num1 < num2 ? T : F
            num2출력
            
    if문 / 가장 많이 사용하는 조건문
        else if, else

    switch문
        case, break, default

반복문
    for문 / 가장 많이 사용하는 반복문
    while문 / 조건식이 '참'인 동안 반복 실행
    do-while문 / 조건식이 '참'인 동안 반복 실행, 작업문은 한 번 반드시 실행

비트개념
    논리 연산: AND, OR, XOR, NOT 연산
        AND = &, OR = |, XOR = ^, NOT = ~a
    시프트 연산: 비트를 오른쪽이나 왼쪽으로 이동
    
배열(array)
    인덱스와 인덱스에 대응하는 데이터들로 이루어진 자료 구조(배열을 이용하면 한 번에 많은 메모리 공간 선언 가능)
    배열은 같은 타입의 데이터들이 순차적으로 저장되는 공간
    
    배열 인덱스
        0부터 시작
        인덱스는 배열의 시작 위치에서부터 데이터가 있는 상대 위치

        intArray = new int[5] / 배열 생성
        int intArray[] = (4,3,2,0,1) / 배열 초기화

    배열의 크기 length
        int size = intArray.length;

    2차원 배열
        int intArray[][]; / 2차원 배열 선언
        intArray = new int[2][5];  int intArray[] = new int[2][5]; // 배열 선언과 생성 동시

## 3월 22일 강의

ctrl + shift + p > java pro > java create java project > 파일 선택 > 파일 이름

자바 : .java > class
자바 사용 장점 : 한번 작성된 코드는 모든 플랫폼에 구애받지 않고(WORA, Write Once Run Anywhere) 돌아감
자바 사용 단점 : JVM(Java Virtual Machine)이 깔려있어야 함

개발하는사람은 JDK를 깔면 되고,
실행하는사람은 JRE를 깔면 된다

식별자란 : 클래스, 변수, 상수, 메소드 등에 붙이는 이름이다
대소문자 구별, Num과 num은 다른 변수이다.

변수 : 값을 임시 저장하기 위한 공간
리터럴 : 값(정수, 실수, 문자, 논리, 문자열 리터럴이 있다)

var키워드
    타입을 생략하고 변수 선언 가능
    컨파일러가 추론하여 변수 타입 결정
    
    변수 선언 시 초깃값이 주어지지 않으면 컴파일 오류 / 초기화 필수

타입변환
    한 타입의 값을 다른 타입의 값으로 변환

## 3월 15일 강의
내용 정리

이번에는 올리지마!!!